diff -ruNp qemu-4.2.0/hw/display/Makefile.objs qemu-4.2.0.new/hw/display/Makefile.objs
--- qemu-4.2.0/hw/display/Makefile.objs	2019-12-12 21:20:47.000000000 +0300
+++ qemu-4.2.0.new/hw/display/Makefile.objs	2019-12-17 13:51:04.631511634 +0300
@@ -42,6 +42,7 @@ common-obj-$(CONFIG_CG3) += cg3.o
 common-obj-$(CONFIG_NEXTCUBE) += next-fb.o
 
 obj-$(CONFIG_VGA) += vga.o
+obj-$(CONFIG_VGT) += vgt_vga.o
 
 common-obj-$(CONFIG_QXL) += qxl.o qxl-logger.o qxl-render.o
 
diff -ruNp qemu-4.2.0/hw/i386/pc_piix.c qemu-4.2.0.new/hw/i386/pc_piix.c
--- qemu-4.2.0/hw/i386/pc_piix.c	2019-12-12 21:20:47.000000000 +0300
+++ qemu-4.2.0.new/hw/i386/pc_piix.c	2019-12-17 13:54:10.600113415 +0300
@@ -60,6 +60,7 @@
 #include "migration/global_state.h"
 #include "migration/misc.h"
 #include "sysemu/numa.h"
+#include "hw/display/vga.h"
 
 #define MAX_IDE_BUS 2
 
@@ -224,7 +225,19 @@ static void pc_init1(MachineState *machi
         x86_register_ferr_irq(x86ms->gsi[13]);
     }
 
-    pc_vga_init(isa_bus, pcmc->pci_enabled ? pci_bus : NULL);
+    /*
+     * Initialize XenGT hooks before normal VGA init. The
+     * ideal case is to have IGD presented as the primary
+     * graphics card in 00:02.0, and then have other emulated
+     * PCI VGA card all disabled. We still rely on Qemu to
+     * emulate legacy ISA ports, so requires the ISA vga logic.
+     */
+    if (vgt_vga_enabled && pcmc->pci_enabled) {
+        vgt_vga_init(pci_bus);
+        isa_create_simple(isa_bus, "isa-vga");
+    } else {
+        pc_vga_init(isa_bus, pcmc->pci_enabled ? pci_bus : NULL);
+    }
 
     assert(pcms->vmport != ON_OFF_AUTO__MAX);
     if (pcms->vmport == ON_OFF_AUTO_AUTO) {
diff -ruNp qemu-4.2.0/hw/i386/xen/xen-hvm.c qemu-4.2.0.new/hw/i386/xen/xen-hvm.c
--- qemu-4.2.0/hw/i386/xen/xen-hvm.c	2019-12-12 21:20:47.000000000 +0300
+++ qemu-4.2.0.new/hw/i386/xen/xen-hvm.c	2019-12-17 13:56:01.050472292 +0300
@@ -216,8 +216,12 @@ static void xen_ram_init(PCMachineState
         user_lowmem = HVM_BELOW_4G_RAM_END;
     }
 
-    if (ram_size >= user_lowmem) {
-        x86ms->above_4g_mem_size = ram_size - user_lowmem;
+    if (vgt_vga_enabled &&
+        ram_size >= 0xc0000000) {
+        x86ms->above_4g_mem_size = ram_size - 0xc0000000;
+        x86ms->below_4g_mem_size = 0xc0000000;
+    } else if (ram_size >= user_lowmem) {
+       x86ms->above_4g_mem_size = ram_size - user_lowmem;
         x86ms->below_4g_mem_size = user_lowmem;
     } else {
         x86ms->above_4g_mem_size = 0;
diff -ruNp qemu-4.2.0/hw/pci/pci.c qemu-4.2.0.new/hw/pci/pci.c
--- qemu-4.2.0/hw/pci/pci.c	2019-12-12 21:20:47.000000000 +0300
+++ qemu-4.2.0.new/hw/pci/pci.c	2019-12-17 13:58:40.996336370 +0300
@@ -48,6 +48,8 @@
 #include "qapi/error.h"
 #include "qapi/qapi-commands-misc.h"
 #include "qemu/cutils.h"
+#include "hw/i386/pc.h"
+#include "hw/display/vga.h"
 
 //#define DEBUG_PCI
 #ifdef DEBUG_PCI
@@ -1015,6 +1017,10 @@ static PCIDevice *do_pci_register_device
     if (devfn < 0) {
         for(devfn = bus->devfn_min ; devfn < ARRAY_SIZE(bus->devices);
             devfn += PCI_FUNC_MAX) {
+            /* If vGT/XenGT is in use, reserve 00:02.* for the IGD */
+            if ((vgt_vga_enabled) && devfn == 0x10)
+                continue;
+
             if (pci_bus_devfn_available(bus, devfn) &&
                    !pci_bus_devfn_reserved(bus, devfn)) {
                 goto found;
@@ -1061,6 +1067,7 @@ static PCIDevice *do_pci_register_device
     pci_dev->irq_state = 0;
     pci_config_alloc(pci_dev);
 
+    printf("set vendor id(%x) for devfn(%x)\n", pc->vendor_id, devfn);
     pci_config_set_vendor_id(pci_dev->config, pc->vendor_id);
     pci_config_set_device_id(pci_dev->config, pc->device_id);
     pci_config_set_revision(pci_dev->config, pc->revision);
@@ -1097,6 +1104,10 @@ static PCIDevice *do_pci_register_device
         config_read = pci_default_read_config;
     if (!config_write)
         config_write = pci_default_write_config;
+    if (vgt_vga_enabled &&
+        config_write == i440fx_write_config) {
+        config_write = vgt_bridge_pci_write;
+    }
     pci_dev->config_read = config_read;
     pci_dev->config_write = config_write;
     bus->devices[devfn] = pci_dev;
diff -ruNp qemu-4.2.0/include/hw/pci/pci_host.h qemu-4.2.0.new/include/hw/pci/pci_host.h
--- qemu-4.2.0/include/hw/pci/pci_host.h	2019-12-12 21:20:47.000000000 +0300
+++ qemu-4.2.0.new/include/hw/pci/pci_host.h	2019-12-17 14:03:37.726360158 +0300
@@ -70,4 +70,7 @@ extern const MemoryRegionOps pci_host_co
 extern const MemoryRegionOps pci_host_data_le_ops;
 extern const MemoryRegionOps pci_host_data_be_ops;
 
+void i440fx_write_config(PCIDevice *dev,
+                         uint32_t address, uint32_t val, int len);
+
 #endif /* PCI_HOST_H */
diff -ruNp qemu-4.2.0/include/sysemu/sysemu.h qemu-4.2.0.new/include/sysemu/sysemu.h
--- qemu-4.2.0/include/sysemu/sysemu.h	2019-12-12 21:20:48.000000000 +0300
+++ qemu-4.2.0.new/include/sysemu/sysemu.h	2019-12-17 14:04:29.069921554 +0300
@@ -27,12 +27,13 @@ extern int autostart;
 
 typedef enum {
     VGA_NONE, VGA_STD, VGA_CIRRUS, VGA_VMWARE, VGA_XENFB, VGA_QXL,
-    VGA_TCX, VGA_CG3, VGA_DEVICE, VGA_VIRTIO,
+    VGA_TCX, VGA_CG3, VGA_DEVICE, VGA_VIRTIO, VGA_VGT,
     VGA_TYPE_MAX,
 } VGAInterfaceType;
 
 extern int vga_interface_type;
 #define xenfb_enabled (vga_interface_type == VGA_XENFB)
+#define vgt_vga_enabled (vga_interface_type == VGA_VGT)
 
 extern int graphic_width;
 extern int graphic_height;
diff -ruNp qemu-4.2.0/Makefile.target qemu-4.2.0.new/Makefile.target
--- qemu-4.2.0/Makefile.target	2019-12-12 21:20:47.000000000 +0300
+++ qemu-4.2.0.new/Makefile.target	2019-12-17 14:05:39.895075402 +0300
@@ -117,6 +117,7 @@ obj-$(CONFIG_TCG) += fpu/softfloat.o
 obj-y += target/$(TARGET_BASE_ARCH)/
 obj-y += disas.o
 obj-$(call notempty,$(TARGET_XML_FILES)) += gdbstub-xml.o
+obj-$(call lnot,$(CONFIG_VGT)) += hw/display/vgt-stub.o
 LIBS := $(libs_cpu) $(LIBS)
 
 obj-$(CONFIG_PLUGIN) += plugins/
diff -ruNp qemu-4.2.0/qemu-options.hx qemu-4.2.0.new/qemu-options.hx
--- qemu-4.2.0/qemu-options.hx	2019-12-12 21:20:48.000000000 +0300
+++ qemu-4.2.0.new/qemu-options.hx	2019-12-17 14:07:46.184915974 +0300
@@ -1594,6 +1594,8 @@ old style -sdl/-curses/... options. Vali
 @item sdl
 Display video output via SDL (usually in a separate graphics
 window; see the SDL documentation for other possibilities).
+@item vgt
+Intel GVT-g technology
 @item curses
 Display video output via curses. For graphics device models which
 support a text mode, QEMU can display this output using a
@@ -1826,7 +1828,7 @@ Rotate graphical output some deg left (o
 ETEXI
 
 DEF("vga", HAS_ARG, QEMU_OPTION_vga,
-    "-vga [std|cirrus|vmware|qxl|xenfb|tcx|cg3|virtio|none]\n"
+    "-vga [std|cirrus|vmware|qxl|xenfb|tcx|cg3|virtio|xengt|none]\n"
     "                select video card type\n", QEMU_ARCH_ALL)
 STEXI
 @item -vga @var{type}
@@ -1861,11 +1863,42 @@ for sun4m machines available in both 102
 resolutions aimed at people wishing to run older Solaris versions.
 @item virtio
 Virtio VGA card.
+@item xengt
+Intel IGD card based on mediated pass-through technique. A single
+IGD card can be used to accelerate multiple VMs, which each run
+native graphics driver inside.
 @item none
 Disable VGA card.
 @end table
 ETEXI
 
+DEF("vgt_low_gm_sz", 1, QEMU_OPTION_vgt_low_gm_sz,
+    "-vgt_low_gm_sz [MB] allocated aperture size\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -vgt_low_gm_sz @var{size}
+@findex -vgt_low_gm_sz
+Set the allocated aperture size.
+ETEXI
+
+DEF("vgt_high_gm_sz", 1, QEMU_OPTION_vgt_high_gm_sz,
+    "-vgt_high_gm_sz [MB] allocated GM size\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -vgt_high_gm_sz @var{size}
+@findex -vgt_high_gm_sz
+Set the allocated aperture size.
+ETEXI
+
+DEF("vgt_fence_sz", 1, QEMU_OPTION_vgt_fence_sz,
+    "-vgt_fence_sz [num] allocated number of fence registers\n",
+    QEMU_ARCH_ALL)
+STEXI
+@item -vgt_fence_sz @var{size}
+@findex -vgt_fence_sz
+Set the allocated aperture size.
+ETEXI
+
 DEF("full-screen", 0, QEMU_OPTION_full_screen,
     "-full-screen    start in full screen\n", QEMU_ARCH_ALL)
 STEXI
diff -ruNp qemu-4.2.0/vl.c qemu-4.2.0.new/vl.c
--- qemu-4.2.0/vl.c	2019-12-12 21:20:48.000000000 +0300
+++ qemu-4.2.0.new/vl.c	2019-12-17 14:10:41.850258094 +0300
@@ -1910,6 +1910,11 @@ static const VGAInterfaceInfo vga_interf
         .opt_name = "xenfb",
         .name = "Xen paravirtualized framebuffer",
     },
+    [VGA_VGT] = {
+        .opt_name = "xengt",
+        .name = "Intel GVT-g",
+        .class_names = { "vgt-vga" },
+    },
 };
 
 static bool vga_interface_available(VGAInterfaceType t)
@@ -1964,6 +1969,7 @@ static void select_vgahw(const MachineCl
                 exit(1);
             }
             vga_interface_type = t;
+	    printf("%s vga is %s\n", __func__, ti->opt_name);
             break;
         }
     }
@@ -3821,6 +3827,26 @@ int main(int argc, char **argv, char **e
             case QEMU_OPTION_nouserconfig:
                 /* Nothing to be parsed here. Especially, do not error out below. */
                 break;
+#ifdef CONFIG_VGT
+            case QEMU_OPTION_vgt_low_gm_sz:
+                {
+                    char *ptr;
+                    vgt_low_gm_sz = strtol(optarg, &ptr, 10);
+                }
+                break;
+            case QEMU_OPTION_vgt_high_gm_sz:
+                {
+                    char *ptr;
+                    vgt_high_gm_sz = strtol(optarg, &ptr, 10);
+                }
+                break;
+            case QEMU_OPTION_vgt_fence_sz:
+                {
+                    char *ptr;
+                    vgt_fence_sz = strtol(optarg, &ptr, 10);
+                }
+                break;
+#endif
             default:
                 if (os_parse_cmd_args(popt->index, optarg)) {
                     error_report("Option not supported in this build");
diff -ruNp qemu-3.0.0/hw/display/vgt_vga.c qemu-3.0.0.new/hw/display/vgt_vga.c
--- qemu-3.0.0/hw/display/vgt_vga.c	1970-01-01 03:00:00.000000000 +0300
+++ qemu-3.0.0.new/hw/display/vgt_vga.c	2019-11-29 16:03:50.258405310 +0300
@@ -0,0 +1,559 @@
+/*
+ * QEMU vGT/XenGT Legacy VGA support
+ *
+ * Copyright (c) 2003 Fabrice Bellard
+ * Copyright (c) Citrix Systems, Inc
+ * Copyright (c) Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+#include "qemu/osdep.h"
+#include "hw/hw.h"
+#include "ui/console.h"
+#include "hw/i386/pc.h"
+#include "hw/pci/pci.h"
+#include "hw/pci/pci_host.h"
+#include "hw/pci/pci_bridge.h"
+#include "hw/pci/pci_bus.h"
+#include "vga_int.h"
+#include "ui/pixel_ops.h"
+#include "qemu/timer.h"
+#include "hw/loader.h"
+#include "qemu/log.h"
+#include "sysemu/arch_init.h"
+#include "sysemu/runstate.h"
+#include "migration/qemu-file-types.h"
+#include "migration/vmstate.h"
+#include "hw/xen/xen.h"
+#include "hw/display/vga.h"
+
+#define DEBUG_VGT
+
+#ifdef DEBUG_VGT
+#define DPRINTF(fmt, ...) \
+    do { fprintf(stderr, "vgt: " fmt, ## __VA_ARGS__); } while (0)
+#else
+#define DPRINTF(fmt, ...) \
+    do { } while (0)
+#endif
+
+typedef struct VGTHostDevice {
+    PCIHostDeviceAddress addr;
+    int config_fd;
+} VGTHostDevice;
+
+typedef struct VGTVMState {
+     struct VGACommonState vga;
+     struct VGTVGAState* parent;
+} VGTVMState;
+
+typedef struct VGTVGAState {
+    PCIDevice dev;
+    struct VGTVMState state;
+    int num_displays;
+    VGTHostDevice host_dev;
+    bool instance_created;
+    int domid;
+} VGTVGAState;
+
+/* These are the default values */
+int vgt_low_gm_sz = 64; /* in MB */
+int vgt_high_gm_sz = 448; /* in MB */
+int vgt_fence_sz = 4;
+int vgt_primary = -1; /* -1 means "not specified */
+int guest_domid = 0;
+
+static int vgt_host_pci_cfg_get(VGTHostDevice *host_dev,
+                                void *data, int len, uint32_t addr);
+static void cpu_update_state(void *pv, int running, RunState state);
+ 
+
+void vgt_bridge_pci_write(PCIDevice *dev,
+                          uint32_t address, uint32_t val, int len)
+{
+    assert(dev->devfn == 0x00);
+
+    i440fx_write_config(dev, address, val, len);
+}
+
+/*
+ *  Inform vGT driver to create a vGT instance
+ */
+static void create_vgt_instance(VGTVGAState *vdev)
+{
+    /* FIXME: this should be substituded as a environment variable */
+    const char *path = "/sys/kernel/vgt/control/create_vgt_instance";
+    FILE *vgt_file;
+    int err = 0;
+    int domid = vdev->domid;
+  
+    qemu_log("vGT: %s: domid=%d, low_gm_sz=%dMB, high_gm_sz=%dMB, "
+        "fence_sz=%d, vgt_primary=%d\n", __func__, domid,
+        vgt_low_gm_sz, vgt_high_gm_sz, vgt_fence_sz, vgt_primary);
+    if (vgt_low_gm_sz <= 0 || vgt_high_gm_sz <=0 ||
+		vgt_primary < -1 || vgt_primary > 1 ||
+        vgt_fence_sz <=0) {
+        qemu_log("vGT: %s failed: invalid parameters!\n", __func__);
+        abort();
+    }
+
+    if ((vgt_file = fopen(path, "w")) == NULL) {
+        err = errno;
+        qemu_log("vGT: open %s failed\n", path);
+    }
+    /* The format of the string is:
+     * domid,aperture_size,gm_size,fence_size. This means we want the vgt
+     * driver to create a vgt instanc for Domain domid with the required
+     * parameters. NOTE: aperture_size and gm_size are in MB.
+     */
+    if (!err && fprintf(vgt_file, "%d,%u,%u,%u,%d,0\n", domid,
+        vgt_low_gm_sz, vgt_high_gm_sz, vgt_fence_sz, vgt_primary) < 0) {
+        err = errno;
+    }
+
+    if (!err && fclose(vgt_file) != 0) {
+        err = errno;
+    }
+
+    if (err) {
+        qemu_log("vGT: %s failed: errno=%d\n", __func__, err);
+        exit(-1);
+    }
+
+    vdev->instance_created = TRUE;
+}
+
+/*
+ *  Inform vGT driver to close a vGT instance
+ */
+static void destroy_vgt_instance(int domid)
+{
+    const char *path = "/sys/kernel/vgt/control/create_vgt_instance";
+    FILE *vgt_file;
+    int err = 0;
+
+    if ((vgt_file = fopen(path, "w")) == NULL) {
+        error_report("vgt: error: open %s failed", path);
+        err = errno;
+    }
+
+    /* -domid means we want the vgt driver to free the vgt instance
+     * of Domain domid.
+     * */
+    if (!err && fprintf(vgt_file, "%d\n", -domid) < 0) {
+        err = errno;
+    }
+
+    if (!err && fclose(vgt_file) != 0) {
+        err = errno;
+    }
+
+    if (err) {
+        qemu_log("vGT: %s: failed: errno=%d\n", __func__, err);
+        exit(-1);
+    }
+}
+
+static int pch_map_irq(PCIDevice *pci_dev, int irq_num)
+{
+    return irq_num;
+}
+
+static int vgt_host_device_get(VGTHostDevice *dev)
+{
+    char name[PATH_MAX];
+
+    snprintf(name, sizeof(name), "/sys/bus/pci/devices/%04x:%02x:%02x.%x/config",
+             dev->addr.domain, dev->addr.bus, dev->addr.slot, dev->addr.function);
+    dev->config_fd = open(name, O_RDONLY);
+    if (dev->config_fd == -1) {
+        error_report("vgt:open failed: %s\n", strerror(errno));
+        return -1;
+     }
+
+    return 0;
+}
+
+static void vgt_host_device_put(VGTHostDevice *dev)
+{
+    if (dev->config_fd >= 0) {
+        close(dev->config_fd);
+        dev->config_fd = -1;
+    }
+}
+
+static int vgt_host_pci_cfg_get(VGTHostDevice *host_dev,
+                                void *data, int len, uint32_t addr)
+{
+    int ret;
+
+    vgt_host_device_get(host_dev);
+    ret = pread(host_dev->config_fd, data, len, addr);
+    if (ret < len) {
+        ret = ret < 0 ? -errno : -EFAULT;
+        error_report("failed to read device config space: %m");
+        goto out;
+    }
+
+out:
+    vgt_host_device_put(host_dev);
+    return ret;
+}
+
+static void vgt_host_bridge_cap_init(PCIDevice *dev, VGTHostDevice *host_dev)
+{
+    assert(dev->devfn == 0x00);
+    uint8_t cap_ptr = 0;
+
+    vgt_host_pci_cfg_get(host_dev, &cap_ptr, 1, PCI_CAPABILITY_LIST);
+    while (cap_ptr !=0) {
+        vgt_host_pci_cfg_get(host_dev, dev->config + cap_ptr, 4, cap_ptr);
+        vgt_host_pci_cfg_get(host_dev, dev->config + cap_ptr + 4, 4,
+                             cap_ptr + 4);
+        vgt_host_pci_cfg_get(host_dev, dev->config + cap_ptr + 8, 4,
+                             cap_ptr + 8);
+        vgt_host_pci_cfg_get(host_dev, dev->config + cap_ptr + 12, 4,
+                             cap_ptr + 12);
+        vgt_host_pci_cfg_get(host_dev, &cap_ptr, 1, cap_ptr + 1);
+    }
+}
+
+static void vgt_host_dev_init(PCIDevice *pdev, VGTHostDevice *host_dev)
+{
+    assert(pdev != NULL && host_dev != NULL);
+
+    host_dev->addr.domain = 0;
+    host_dev->addr.bus = pci_dev_bus_num(pdev);
+    host_dev->addr.slot = PCI_SLOT(pdev->devfn);
+    host_dev->addr.function = PCI_FUNC(pdev->devfn);
+}
+
+void vgt_bridge_pci_conf_init(PCIDevice *pdev)
+{
+    printf("vgt_bridge_pci_conf_init\n");
+    VGTHostDevice host_dev;
+
+    vgt_host_dev_init(pdev, &host_dev);
+
+    vgt_host_pci_cfg_get(&host_dev, pdev->config, 2, 0x00);
+    printf("vendor id: %x\n", *(uint16_t *)((char *)pdev->config + 0x00));
+
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x02, 2, 0x02);
+    printf("device id: %x\n", *(uint16_t *)((char *)pdev->config + 0x02));
+    /* status */
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x06, 2, 0x06);
+    /* revision id */
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x08, 2, 0x08);
+    /* capability */
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x34, 1, 0x34);
+    vgt_host_bridge_cap_init(pdev, &host_dev);
+
+    /* SNB: processor graphics control register */
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x50, 2, 0x50);
+    /* processor graphics control register */
+    vgt_host_pci_cfg_get(&host_dev, pdev->config + 0x52, 2, 0x52);
+}
+
+static void vgt_reset(DeviceState *dev)
+{
+    PCIDevice *pdev = DO_UPCAST(PCIDevice, qdev, dev);
+    VGTVGAState *d = DO_UPCAST(VGTVGAState, dev, pdev);
+
+    if (d->instance_created) {
+        destroy_vgt_instance(d->domid);
+    }
+
+    create_vgt_instance(d);
+}
+
+static void vgt_cleanupfn(PCIDevice *dev)
+{
+    VGTVGAState *d = DO_UPCAST(VGTVGAState, dev, dev);
+
+    if (d->instance_created) {
+        destroy_vgt_instance(d->domid);
+    }
+}
+
+static int vgt_get_domid(void)
+{
+    int domid = 0;
+
+    domid = xen_domid;
+    assert(domid > 0);
+    guest_domid = domid;
+
+    return domid;
+}
+
+static void vgt_initfn(PCIDevice *dev, Error **errp)
+{
+    VGTVGAState *d = DO_UPCAST(VGTVGAState, dev, dev);
+
+    DPRINTF("vgt_initfn\n");
+    vgt_host_dev_init(dev, &d->host_dev);
+    d->domid = vgt_get_domid();
+    d->state.parent = d;
+    qemu_add_vm_change_state_handler(cpu_update_state, d);
+}
+
+DeviceState *vgt_vga_init(PCIBus *pci_bus)
+{
+    PCIDevice *dev;
+    PCIBridge *br;
+    uint16_t vendor_id;
+    uint16_t device_id;
+    uint8_t revision_id;
+    uint16_t class_dev;
+    VGTHostDevice host_dev = {
+        .addr.domain = 0,
+        .addr.bus = 0,
+        .addr.slot = 0x1f,
+        .addr.function = 0,
+    };
+
+    vgt_host_pci_cfg_get(&host_dev, &vendor_id, sizeof(vendor_id),
+                         PCI_VENDOR_ID);
+    vgt_host_pci_cfg_get(&host_dev, &device_id, sizeof(device_id),
+                         PCI_DEVICE_ID);
+    vgt_host_pci_cfg_get(&host_dev, &revision_id, sizeof(revision_id),
+                         PCI_REVISION_ID);
+    vgt_host_pci_cfg_get(&host_dev, &class_dev, sizeof(class_dev),
+                         PCI_CLASS_DEVICE);
+    DPRINTF("vendor: 0x%hx, device: 0x%hx, revision: 0x%hhx\n",
+            vendor_id, device_id, revision_id);
+
+    if (vendor_id != PCI_VENDOR_ID_INTEL) {
+        error_report("vgt: error: vgt-vga is only supported on Intel GPUs");
+        return NULL;
+    }
+
+    dev = pci_create_multifunction(pci_bus, PCI_DEVFN(0x1f, 0), true,
+                                   "vgt-isa");
+    if (!dev) {
+        error_report("vgt: error: vgt-isa not available");
+        return NULL;
+    }
+
+    qdev_init_nofail(&dev->qdev);
+
+    pci_config_set_vendor_id(dev->config, vendor_id);
+    pci_config_set_device_id(dev->config, device_id);
+    pci_config_set_revision(dev->config, revision_id);
+    pci_config_set_class(dev->config, class_dev);
+    br = PCI_BRIDGE(dev);
+    pci_bridge_map_irq(br, "IGD Bridge",
+                       pch_map_irq);
+
+    printf("Create vgt ISA bridge successfully\n");
+
+    dev = pci_create_multifunction(pci_bus, PCI_DEVFN(0x2, 0), true,
+                                   "vgt-vga");
+    if (!dev) {
+        error_report("vgt: error: vgt-vga not available");
+        return NULL;
+    }
+
+    qdev_init_nofail(&dev->qdev);
+    printf("Create vgt VGA successfully\n");
+    return DEVICE(dev);
+}
+
+static void vgt_pause(int domid, bool dev_state)
+{
+    char file_name[PATH_MAX] = {0};
+    FILE *fp = NULL;
+    int err = 0;
+
+    snprintf(file_name, PATH_MAX, "/sys/kernel/vgt/vm%d/schedule", domid);
+
+    fp = fopen(file_name, "w");
+    if (fp == NULL) {
+        err = errno;
+        qemu_log("vGT: open %s failed\n", file_name);
+    }
+
+    if (!err && fprintf(fp, "%d\n", !dev_state) < 0) {
+        err = errno;
+    }
+
+    if (!err && fclose(fp) != 0) {
+        err = errno;
+    }
+
+    if (err) {
+        qemu_log("vGT: %s failed: errno=%d\n", __func__, err);
+        exit(-1);
+    }
+}
+
+static void cpu_update_state(void *pv, int running, RunState state)
+{
+    VGTVGAState *d = (VGTVGAState *) pv;
+    if (!running) {
+        vgt_pause(d->domid, true);
+    }
+}
+
+static void read_write_state(QEMUFile *f, VGTVGAState *d, bool is_read)
+{
+    char file_name[PATH_MAX] = {0};
+    FILE *fp = NULL;
+    struct stat st;
+    int sz;
+    uint8_t *buf = NULL;
+    int count = 0;
+
+    snprintf(file_name, PATH_MAX, "/sys/kernel/vgt/vm%d/device_state", d->domid);
+
+    fp = fopen(file_name, "r+");
+    if (fp == NULL) {
+        qemu_log("vGT: %s failed to open file %s! errno = %d",
+                __func__, file_name, errno);
+        goto EXIT;
+    }
+
+    fstat(fileno(fp), &st);
+    sz = st.st_size;
+
+    if (sz <= 0) {
+        qemu_log("vGT: failed to achieve file size. file name=%s",
+               file_name);
+        goto EXIT;
+    }
+
+    buf = g_malloc(sz);
+    if (buf == NULL) {
+        qemu_log("vGT: %s failed to allocate memory size %d! errno = %d",
+                __func__, sz, errno);
+        goto EXIT;
+    }
+
+    DPRINTF("Allocate %d size of buffer for device state\n", sz);
+
+    if (is_read) {
+        count = fread(buf, 1, sz, fp);
+        qemu_put_buffer(f, buf, sz);
+    } else {
+        qemu_get_buffer(f, buf, sz);
+        count = fwrite(buf, 1, sz, fp);
+    }
+
+    if (count != sz) {
+        qemu_log("vGT: read/write snapshot file size is differ %d:%d",
+                count, sz);
+    }
+
+    DPRINTF("[%s] %d size of buffer for device state\n",
+            is_read ? "READ":"WRITE", count);
+
+EXIT:
+    g_free(buf);
+    if (fp) {
+        fclose(fp);
+    }
+    return;
+}
+
+static int vgt_device_get(QEMUFile *f, void *pv,
+                          size_t size, const VMStateField *field)
+{
+    VGTVGAState *d = (VGTVGAState *) pv;
+
+    read_write_state(f, d, false);
+
+    vgt_pause(d->domid, false);
+    return 0;
+}
+
+static int vgt_device_put(QEMUFile *f, void *pv, size_t size,
+                          const VMStateField *field, QJSON *vmdesc)
+{
+    VGTVGAState *d = (VGTVGAState *) pv;
+
+    read_write_state(f, d, true);
+
+    destroy_vgt_instance(d->domid);
+    return 0;
+}
+
+static const VMStateInfo vmstate_info_vgt = {
+    .name = "vgt state",
+    .get  = vgt_device_get,
+    .put  = vgt_device_put,
+};
+
+static const VMStateDescription vmstate_vga_vgt = {
+    .name = "vgt-vga",
+    .version_id = 2,
+    .minimum_version_id = 2,
+    .fields = (VMStateField[]) {
+        {
+            .name         = "vgt dev",
+            .version_id   = 0,
+            .field_exists = NULL,
+            .size         = 0,
+            .info         = &vmstate_info_vgt,
+            .flags        = VMS_SINGLE,
+            .offset       = 0,
+        },
+
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+static void vgt_class_initfn(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    PCIDeviceClass *ic = PCI_DEVICE_CLASS(klass);
+    ic->realize = vgt_initfn;
+    dc->reset = vgt_reset;
+    ic->exit = vgt_cleanupfn;
+    dc->vmsd = &vmstate_vga_vgt;
+}
+
+static TypeInfo vgt_info = {
+    .name          = "vgt-vga",
+    .parent        = TYPE_PCI_DEVICE,
+    .instance_size = sizeof(VGTVGAState),
+    .class_init    = vgt_class_initfn,
+    .interfaces = (InterfaceInfo[]) {
+        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
+        { }
+    },
+};
+
+static TypeInfo isa_info = {
+    .name          = "vgt-isa",
+    .parent        = TYPE_PCI_BRIDGE,
+    .instance_size = sizeof(PCIBridge),
+    .interfaces = (InterfaceInfo[]) {
+        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
+        { }
+    },
+
+};
+
+static void vgt_register_types(void)
+{
+    type_register_static(&vgt_info);
+    type_register_static(&isa_info);
+}
+
+type_init(vgt_register_types)
diff -ruNp qemu-3.0.0/include/hw/display/vgt-stub.c qemu-3.0.0.new/include/hw/display/vgt-stub.c
--- qemu-3.0.0/include/hw/display/vgt-stub.c	1970-01-01 03:00:00.000000000 +0300
+++ qemu-3.0.0.new/include/hw/display/vgt-stub.c	2019-11-29 15:53:26.960621777 +0300
@@ -0,0 +1,31 @@
+/*
+ * QEMU VGT support
+ *
+ * Copyright (c) Intel
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.  See
+ * the COPYING file in the top-level directory.
+ *
+ */
+#include "hw/hw.h"
+#include "ui/console.h"
+#include "hw/i386/pc.h"
+
+DeviceState *vgt_vga_init(PCIBus *pci_bus)
+{
+    return NULL;
+}
+
+void vgt_bridge_pci_conf_init(PCIDevice *pdev)
+{
+}
+
+void vgt_kvm_set_opregion_addr(uint32_t addr)
+{
+}
+
+void vgt_bridge_pci_write(PCIDevice *dev,
+                          uint32_t address, uint32_t val, int len)
+{
+}
+
diff -ruNp qemu-4.2.0/configure qemu-4.2.0.new/configure
--- qemu-4.2.0/configure	2019-12-12 21:20:47.000000000 +0300
+++ qemu-4.2.0.new/configure	2019-12-17 14:27:17.150831305 +0300
@@ -377,6 +377,7 @@ libattr=""
 xfs=""
 tcg="yes"
 membarrier=""
+vgt="yes"
 vhost_net=""
 vhost_crypto=""
 vhost_scsi=""
@@ -1067,6 +1068,10 @@ for opt do
   ;;
   --enable-sdl-image) sdl_image="yes"
   ;;
+  --disable-vgt) vgt="no"
+  ;;
+  --enable-vgt) vgt="yes"
+  ;;
   --disable-qom-cast-debug) qom_cast_debug="no"
   ;;
   --enable-qom-cast-debug) qom_cast_debug="yes"
@@ -1742,6 +1747,7 @@ disabled with --disable-FEATURE, default
   gnutls          GNUTLS cryptography support
   nettle          nettle cryptography support
   gcrypt          libgcrypt cryptography support
+  vgt		  Intel GVT-g technology
   auth-pam        PAM access control
   sdl             SDL UI
   sdl-image       SDL Image support for icons
@@ -3164,6 +3170,12 @@ EOF
 fi
 
 ##########################################
+# Intel GVT-g detection
+if test "$vgt" = "yes" ; then
+  vgt="yes"
+fi
+
+##########################################
 # RDMA needs OpenFabrics libraries
 if test "$rdma" != "no" ; then
   cat > $TMPC <<EOF
@@ -6470,6 +6482,7 @@ if test "$darwin" = "yes" ; then
 fi
 echo "SDL support       $sdl $(echo_version $sdl $sdlversion)"
 echo "SDL image support $sdl_image"
+echo "Intel GVT-g support $vgt"
 echo "GTK support       $gtk $(echo_version $gtk $gtk_version)"
 echo "GTK GL support    $gtk_gl"
 echo "VTE support       $vte $(echo_version $vte $vteversion)"
@@ -6827,6 +6840,9 @@ if test "$sdl" = "yes" ; then
       echo "CONFIG_SDL_IMAGE=y" >> $config_host_mak
   fi
 fi
+if test "$vgt" = "yes" ; then
+  echo "CONFIG_VGT=y" >> $config_host_mak
+fi
 if test "$cocoa" = "yes" ; then
   echo "CONFIG_COCOA=y" >> $config_host_mak
 fi
diff -ruNp qemu-4.2.0/include/hw/display/vga.h qemu-4.2.0.new/include/hw/display/vga.h
--- qemu-4.2.0/include/hw/display/vga.h	2019-12-12 21:20:47.000000000 +0300
+++ qemu-4.2.0.new/include/hw/display/vga.h	2019-12-17 15:06:24.477094904 +0300
@@ -21,5 +22,13 @@ extern enum vga_retrace_method vga_retra
 int isa_vga_mm_init(hwaddr vram_base,
                     hwaddr ctrl_base, int it_shift,
                     MemoryRegion *address_space);
+/* vgt_vga.c */
+extern int vgt_low_gm_sz;
+extern int vgt_high_gm_sz;
+extern int vgt_fence_sz;
 
+DeviceState *vgt_vga_init(PCIBus *pci_bus);
+void vgt_bridge_pci_conf_init(PCIDevice *dev);
+void vgt_bridge_pci_write(PCIDevice *dev,
+                          uint32_t address, uint32_t val, int len);
 #endif
diff -ruNp qemu-4.2.0/hw/pci-host/i440fx.c qemu-4.2.0.new/hw/pci-host/i440fx.c
--- qemu-4.2.0/hw/pci-host/i440fx.c	2019-12-12 21:20:47.000000000 +0300
+++ qemu-4.2.0.new/hw/pci-host/i440fx.c	2019-12-17 15:17:09.979912417 +0300
@@ -34,6 +34,8 @@
 #include "hw/pci-host/pam.h"
 #include "qapi/visitor.h"
 #include "qemu/error-report.h"
+#include "hw/display/vga.h"
+#include "sysemu/sysemu.h"
 
 /*
  * I440FX chipset data sheet.
@@ -98,7 +100,7 @@ static void i440fx_update_memory_mapping
 }
 
 
-static void i440fx_write_config(PCIDevice *dev,
+void i440fx_write_config(PCIDevice *dev,
                                 uint32_t address, uint32_t val, int len)
 {
     PCII440FXState *d = I440FX_PCI_DEVICE(dev);
@@ -267,6 +269,10 @@ static void i440fx_realize(PCIDevice *de
     if (object_property_get_bool(qdev_get_machine(), "iommu", NULL)) {
         warn_report("i440fx doesn't support emulated iommu");
     }
+
+    if (vgt_vga_enabled) {
+        vgt_bridge_pci_conf_init(dev);
+    }
 }
 
 PCIBus *i440fx_init(const char *host_type, const char *pci_type,
